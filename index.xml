<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Remco Docs</title>
    <link>https://heavyhorst.github.io/remco/index.xml</link>
    <description>Recent content on Remco Docs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license</copyright>
    <lastBuildDate>Sat, 03 Dec 2016 15:11:07 +0100</lastBuildDate>
    <atom:link href="https://heavyhorst.github.io/remco/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Plugins</title>
      <link>https://heavyhorst.github.io/remco/plugins/</link>
      <pubDate>Sat, 03 Dec 2016 15:11:07 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/plugins/</guid>
      <description>

&lt;h3 id=&#34;chapter-4&#34;&gt;Chapter 4&lt;/h3&gt;

&lt;h1 id=&#34;plugins&#34;&gt;Plugins&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Template</title>
      <link>https://heavyhorst.github.io/remco/template/</link>
      <pubDate>Sat, 03 Dec 2016 15:02:45 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/template/</guid>
      <description>

&lt;h3 id=&#34;chapter-3&#34;&gt;Chapter 3&lt;/h3&gt;

&lt;h1 id=&#34;templates&#34;&gt;Templates&lt;/h1&gt;

&lt;p&gt;Templates are written in flosch&amp;rsquo;s &lt;a href=&#34;https://github.com/flosch/pongo2&#34;&gt;&lt;code&gt;pongo2&lt;/code&gt;&lt;/a&gt; template engine.&lt;/p&gt;

&lt;div class=&#34;notices tip&#34; &gt;&lt;p&gt;For a documentation on how the templating language works you can &lt;a href=&#34;https://docs.djangoproject.com/en/dev/topics/templates/&#34;&gt;head over to the Django documentation&lt;/a&gt;. pongo2 aims to be compatible with it.&lt;/p&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Configuration</title>
      <link>https://heavyhorst.github.io/remco/config/</link>
      <pubDate>Sat, 03 Dec 2016 14:37:29 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/config/</guid>
      <description>

&lt;h3 id=&#34;chapter-2&#34;&gt;Chapter 2&lt;/h3&gt;

&lt;h1 id=&#34;configuration&#34;&gt;Configuration&lt;/h1&gt;

&lt;p&gt;The configuration file is in TOML format.&lt;br&gt;
TOML looks very similar to INI configuration formats, but with slightly more rich data structures and nesting support.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Details</title>
      <link>https://heavyhorst.github.io/remco/details/</link>
      <pubDate>Sat, 03 Dec 2016 14:19:23 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/details/</guid>
      <description>

&lt;h3 id=&#34;chapter-1&#34;&gt;Chapter 1&lt;/h3&gt;

&lt;h1 id=&#34;details&#34;&gt;Details&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Examples</title>
      <link>https://heavyhorst.github.io/remco/examples/</link>
      <pubDate>Sat, 03 Dec 2016 14:19:23 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/examples/</guid>
      <description>

&lt;h3 id=&#34;chapter-5&#34;&gt;Chapter 5&lt;/h3&gt;

&lt;h1 id=&#34;examples&#34;&gt;Examples&lt;/h1&gt;

&lt;p&gt;This is a collection of different examples.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>env plugin example</title>
      <link>https://heavyhorst.github.io/remco/plugins/env-plugin-example/</link>
      <pubDate>Sat, 03 Dec 2016 15:13:50 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/plugins/env-plugin-example/</guid>
      <description>&lt;p&gt;This is the env backend as a plugin.
If you want to try it yourself, then
just compile it and move the executable to /etc/remco/plugins.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/rpc/jsonrpc&amp;quot;

	&amp;quot;github.com/HeavyHorst/easyKV&amp;quot;
	&amp;quot;github.com/HeavyHorst/easyKV/env&amp;quot;
	&amp;quot;github.com/HeavyHorst/remco/backends/plugin&amp;quot;
	&amp;quot;github.com/natefinch/pie&amp;quot;
)

func main() {
	p := pie.NewProvider()
	if err := p.RegisterName(&amp;quot;Plugin&amp;quot;, &amp;amp;EnvRPCServer{}); err != nil {
		log.Fatalf(&amp;quot;failed to register Plugin: %s&amp;quot;, err)
	}
	p.ServeCodec(jsonrpc.NewServerCodec)
}

type EnvRPCServer struct {
	// This is the real implementation
	Impl easyKV.ReadWatcher
}

func (e *EnvRPCServer) Init(args map[string]interface{}, resp *bool) error {
	// use the data in args to create the ReadWatcher
	// env var doesn&#39;t need any data

	var err error
	e.Impl, err = env.New()
	return err
}

func (e *EnvRPCServer) GetValues(args []string, resp *map[string]string) error {
	erg, err := e.Impl.GetValues(args)
	if err != nil {
		return err
	}
	*resp = erg
	return nil
}

func (e *EnvRPCServer) Close(args interface{}, resp *interface{}) error {
	e.Impl.Close()
	return nil
}

func (e EnvRPCServer) WatchPrefix(args plugin.WatchConfig, resp *uint64) error {
	var err error
	*resp, err = e.Impl.WatchPrefix(context.Background(), args.Prefix, easyKV.WithKeys(args.Opts.Keys), easyKV.WithWaitIndex(args.Opts.WaitIndex))
	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create a config file with this backend section.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[backend]
  [[backend.plugin]]
    path = &amp;quot;/etc/remco/plugins/env&amp;quot;
    keys = [&amp;quot;/&amp;quot;]
    interval = 60
	watch = false
	[backend.plugin.config]
	 # these parameters are not used in the env backend plugin
	 # but other plugins may need some data (password, prefix ...)
	 a = &amp;quot;hallo&amp;quot;
	 b = &amp;quot;moin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>template functions</title>
      <link>https://heavyhorst.github.io/remco/template/template-functions/</link>
      <pubDate>Sat, 03 Dec 2016 15:06:33 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/template/template-functions/</guid>
      <description>

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;exists&lt;/strong&gt; &amp;ndash; Checks if the key exists. Return false if key is not found.&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% if exists(&amp;quot;/key&amp;quot;) %}
    value: {{ getv (&amp;quot;/key&amp;quot;) }}
{% endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;get&lt;/strong&gt; &amp;ndash; Returns the KVPair where key matches its argument.&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% with get(&amp;quot;/key&amp;quot;) as dat %}
    key: {{dat.Key}}
    value: {{dat.Value}}
{% endwith %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;gets&lt;/strong&gt; &amp;ndash; Returns all KVPair, []KVPair, where key matches its argument.&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for i in gets(&amp;quot;/*&amp;quot;) %}
    key: {{i.Key}}
    value: {{i.Value}}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;getv&lt;/strong&gt; &amp;ndash; Returns the value as a string where key matches its argument or an optional default value.&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;value: {{ getv(&amp;quot;/key&amp;quot;) }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;with-a-default-value&#34;&gt;With a default value&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;value: {{ getv(&amp;quot;/key&amp;quot;, &amp;quot;default_value&amp;quot;) }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;getvs&lt;/strong&gt; &amp;ndash; Returns all values, []string, where key matches its argument.&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for value in getvs(&amp;quot;/*&amp;quot;) %}
    value: {{value}}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;getenv&lt;/strong&gt; &amp;ndash; Retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. Optionally, you can give a default value that will be returned if the key is not present. &lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export HOSTNAME=`hostname`
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;hostname: {{getenv(&amp;quot;HOSTNAME&amp;quot;)}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;with-a-default-value-1&#34;&gt;With a default value&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;ipaddr: {{ getenv(&amp;quot;HOST_IP&amp;quot;, &amp;quot;127.0.0.1&amp;quot;) }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;ls&lt;/strong&gt; &amp;ndash; Returns all subkeys, []string, where path matches its argument. Returns an empty list if path is not found. &lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for i in ls(&amp;quot;/deis/services&amp;quot;) %}
   value: {{i}}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;lsdir&lt;/strong&gt; &amp;ndash; Returns all subkeys, []string, where path matches its argument. It only returns subkeys that also have subkeys. Returns an empty list if path is not found. &lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for dir in lsdir(&amp;quot;/deis/services&amp;quot;) %}
   value: {{dir}}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;replace&lt;/strong&gt; &amp;ndash; Alias for the &lt;a href=&#34;https://golang.org/pkg/strings/#Replace&#34;&gt;strings.Replace&lt;/a&gt; function. &lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;backend = {{ replace(getv(&amp;quot;/services/backend/nginx&amp;quot;), &amp;quot;-&amp;quot;, &amp;quot;_&amp;quot;, -1) }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;contains&lt;/strong&gt; &amp;ndash; Alias for the &lt;a href=&#34;https://golang.org/pkg/strings/#Contains&#34;&gt;strings.Contains&lt;/a&gt; function. &lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% if contains(getv(&amp;quot;/services/backend/nginx&amp;quot;), &amp;quot;something&amp;quot;) %}
something
{% endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;printf&lt;/strong&gt; &amp;ndash; Alias for the &lt;a href=&#34;https://golang.org/pkg/fmt/#Sprintf&#34;&gt;fmt.Sprintf&lt;/a&gt; function. &lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ getv (printf (&amp;quot;/config/%s/host_port&amp;quot;, dir)) }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;unixTS&lt;/strong&gt; &amp;ndash; Wrapper for &lt;a href=&#34;https://golang.org/pkg/time/#Unix&#34;&gt;time.Now().Unix()&lt;/a&gt;. &lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ unixTS }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;dateRFC3339&lt;/strong&gt; &amp;ndash; Wrapper for &lt;a href=&#34;https://golang.org/pkg/time/&#34;&gt;time.Now().Format(time.RFC3339)&lt;/a&gt;. &lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ dateRFC3339 }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;lookupIP&lt;/strong&gt; &amp;ndash; Wrapper for the &lt;a href=&#34;https://golang.org/pkg/net/#LookupIP&#34;&gt;net.LookupIP&lt;/a&gt; function. The wrapper returns the IP addresses in alphabetical order. &lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for ip in lookupIP(&amp;quot;kube-master&amp;quot;) %}
 {{ ip }}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;lookupSRV&lt;/strong&gt; &amp;ndash; Wrapper for the &lt;a href=&#34;https://golang.org/pkg/net/#LookupSRV&#34;&gt;net.LookupSRV&lt;/a&gt; function. The wrapper returns the SRV records in alphabetical order. &lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for srv in lookupSRV(&amp;quot;xmpp-server&amp;quot;, &amp;quot;tcp&amp;quot;, &amp;quot;google.com&amp;quot;) %}
  target: {{ srv.Target }}
  port: {{ srv.Port }}
  priority: {{ srv.Priority }}
  weight: {{ srv.Weight }}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;createMap&lt;/strong&gt; &amp;ndash; create a hashMap to store values at runtime. This can be useful if you want to generate json/yaml files. &lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% set map = createMap() %}
{{ map.Set(&amp;quot;Moin&amp;quot;, &amp;quot;Hallo2&amp;quot;) }}
{{ map.Set(&amp;quot;Test&amp;quot;, 105) }}
{{ map | toYAML }}

{% set map2 = createMap() %}
{{ map2.Set(&amp;quot;Moin&amp;quot;, &amp;quot;Hallo&amp;quot;) }}
{{ map2.Set(&amp;quot;Test&amp;quot;, 300) }}
{{ map2.Set(&amp;quot;anotherMap&amp;quot;, map) }}
{{ map2 | toYAML }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The hashmap supports the following methods:
* &lt;code&gt;m.Set(&amp;quot;key&amp;quot;, value)&lt;/code&gt; adds a new value of arbitrary type referenced by &amp;ldquo;key&amp;rdquo; to the map
* &lt;code&gt;m.Get(&amp;quot;key&amp;quot;)&lt;/code&gt; get the value for the given &amp;ldquo;key&amp;rdquo;
* &lt;code&gt;m.Remove(&amp;quot;key&amp;quot;)&lt;/code&gt; removes the key and value from the map
&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;createSet&lt;/strong&gt; &amp;ndash; create a Set to store values at runtime. This can be useful if you want to generate json/yaml files. &lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% set s = createSet() %}
{{ s.Append(&amp;quot;Moin&amp;quot;) }}
{{ s.Append(&amp;quot;Moin&amp;quot;) }}
{{ s.Append(&amp;quot;Hallo&amp;quot;) }}
{{ s.Append(1) }}
{{ s.Remove(&amp;quot;Hallo&amp;quot;) }}
{{ s | toYAML }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The set created supports the following methods:
* &lt;code&gt;s.Append(&amp;quot;string&amp;quot;)&lt;/code&gt; adds a new string to the set. Attention - the set is not
  sorted or the order of appended elements guaranteed.
* &lt;code&gt;s.Remove(&amp;quot;string&amp;quot;)&lt;/code&gt; removes the given element from the set.
* &lt;code&gt;s.Contains(&amp;quot;string&amp;quot;)&lt;/code&gt; check if the given string is part of the set, returns
  true or false otherwise
* &lt;code&gt;s.SortedSet()&lt;/code&gt; return a new list where all elements are sorted in increasing
  order. This method should be used inside the template with a for-in loop to generate
 a stable output file not changing order of elements on every run.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% set s = createSet() %}
{% s.Append(&amp;quot;Moin&amp;quot;) %}
{% s.Append(&amp;quot;Hi&amp;quot;) %}
{% s.Append(&amp;quot;Hallo&amp;quot;) %}

{% for greeting in s %}
{{ geeting }}
{% endfor %}

{% for greeting in s.SortedSet() %}
{{ geeting }}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output of the first loop is not defined, it can be in every order (like &lt;code&gt;Moin Hallo Hi&lt;/code&gt; or &lt;code&gt;Hi Hallo Moin&lt;/code&gt; and so on)
The second loop returns every time &lt;code&gt;Hallo Hi Moin&lt;/code&gt; (items sorted as string in increasing order)
&lt;/details&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic haproxy configuration with docker, registrator and etcd</title>
      <link>https://heavyhorst.github.io/remco/examples/haproxy/</link>
      <pubDate>Sat, 03 Dec 2016 14:56:09 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/examples/haproxy/</guid>
      <description>

&lt;h2 id=&#34;the-haproxy-template&#34;&gt;The haproxy template&lt;/h2&gt;

&lt;p&gt;We expect &lt;a href=&#34;http://gliderlabs.github.io/registrator/latest/&#34;&gt;registrator&lt;/a&gt; to write the service data in this format to etcd:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/services/&amp;lt;service-name&amp;gt;/&amp;lt;service-id&amp;gt; = &amp;lt;ip&amp;gt;:&amp;lt;port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The scheme (tcp, http) and the host_port of the service is configurable over the following keys:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/config/&amp;lt;service-name&amp;gt;/scheme
/config/&amp;lt;service-name&amp;gt;/host_port
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We create the template for the haproxy configuration file first.
Create the file &lt;strong&gt;haproxy.tmpl&lt;/strong&gt; and add the following config blocks:&lt;/p&gt;

&lt;p&gt;Some default configuration parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global
    daemon
    maxconn 2048

defaults
    timeout connect 5000ms
    timeout client 500000ms
    timeout server 500000ms
    log global

frontend name_resolver_http
    bind *:80
    mode http
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;p&gt;This block creates the &lt;em&gt;http&lt;/em&gt; acl&amp;rsquo;s.
We itarate over all directories under /config  (the services) and create a &lt;strong&gt;url_beg&lt;/strong&gt; and a &lt;strong&gt;hdr_beg(host)&lt;/strong&gt; acl if the service has a scheme configured.
Note that we sort the services by length and iterate in reversed order (longest services first). That way we can have services with the same prefix, for example redis_test, and redis.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for dir in lsdir(&amp;quot;/config&amp;quot;) | sortByLength reversed %}
  {% if exists(printf(&amp;quot;/config/%s/scheme&amp;quot;, dir)) %}
    {% if getv(printf(&amp;quot;/config/%s/scheme&amp;quot;, dir)) == &amp;quot;http&amp;quot; %}
      {% if ls(printf(&amp;quot;/services/%s&amp;quot;, dir)) %}
        acl is_{{ dir }} url_beg /{{ dir }}
        acl is_{{ dir }} hdr_beg(host) {{ dir }}
        use_backend {{ dir }}_servers if is_{{ dir }}
      {% endif %}
    {% endif %}
  {% endif %}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we had one service named redis we would get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;acl is_redis url_beg /redis 
acl is_redis hdr_beg(host) redis
use_backend redis_servers if is_redis
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;p&gt;Optional template block to expose a service on an host port:
We iterate over all services under /config, test if the scheme and host_port is configured and create the host port configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for dir in lsdir(&amp;quot;/config&amp;quot;) %}
  {% if exists (printf (&amp;quot;/config/%s/scheme&amp;quot;, dir )) %}
    {% if exists (printf(&amp;quot;/config/%s/host_port&amp;quot;, dir )) %}
      {% if ls(printf(&amp;quot;/services/%s&amp;quot;, dir)) %}
                frontend {{ dir }}_port
                mode {{ getv (printf(&amp;quot;/config/%s/scheme&amp;quot;, dir)) }}
                bind *:{{ getv (printf (&amp;quot;/config/%s/host_port&amp;quot;, dir)) }}
                default_backend {{ dir }}_servers
      {% endif %}
    {% endif %}
  {% endif %}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we had one service named redis with scheme=tcp and host_port=6379 we would get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;frontend redis_port
mode tcp
bind *:6379 
default_backend redis_servers
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;p&gt;The last block creates the haproxy backends.
We iterate over all services and, if a scheme is set, create the backend &lt;em&gt;{service_name}_servers&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for dir in lsdir(&amp;quot;/services&amp;quot;) %}
  {% if exists(printf(&amp;quot;/config/%s/scheme&amp;quot;, dir)) %}
backend {{ dir }}_servers
        mode {{ getv (printf (&amp;quot;/config/%s/scheme&amp;quot;, dir)) }}
        {% for i in gets (printf(&amp;quot;/services/%s/*&amp;quot;, dir)) %}
            server server_{{ dir }}_{{ base (i.Key) }} {{ i.Value }}
        {% endfor %}
    {% endif %}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we had one service named redis with scheme=tcp we could get for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;backend redis_servers   
  mode tcp
    server server_redis_1 192.168.0.10:32012
    server server_redis_2 192.168.0.10:35013
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h2 id=&#34;the-remco-configuration-file&#34;&gt;The remco configuration file&lt;/h2&gt;

&lt;p&gt;We also need to create the remco configuration file.
Create a file named &lt;strong&gt;config&lt;/strong&gt; and insert the following toml configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;################################################################
# Global configuration
################################################################
log_level = &amp;quot;debug&amp;quot;
log_format = &amp;quot;text&amp;quot;

[[resource]]
name = &amp;quot;haproxy&amp;quot;

[[resource.template]]
  src = &amp;quot;/etc/remco/templates/haproxy.tmpl&amp;quot;
  dst = &amp;quot;/etc/haproxy/haproxy.cfg&amp;quot;
  reload_cmd 	  = &amp;quot;haproxy -f {{.dst}} -p /var/run/haproxy.pid -D -sf `cat /var/run/haproxy.pid`&amp;quot;

  [resource.backend]
    [resource.backend.etcd]
      nodes = [&amp;quot;${ETCD_NODE}&amp;quot;]
      keys = [&amp;quot;/services&amp;quot;, &amp;quot;/config&amp;quot;]
      watchKeys = [&amp;quot;/haproxy/reload&amp;quot;]
      watch = true
      interval = 60
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-dockerfile&#34;&gt;The Dockerfile&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;FROM alpine:3.4

ENV REMCO_VER 0.8.0

RUN apk --update add --no-cache haproxy bash ca-certificates
RUN wget https://github.com/HeavyHorst/remco/releases/download/v${REMCO_VER}/remco_${REMCO_VER}_linux_amd64.zip &amp;amp;&amp;amp; \
    unzip remco_${REMCO_VER}_linux_amd64.zip &amp;amp;&amp;amp; rm remco_${REMCO_VER}_linux_amd64.zip &amp;amp;&amp;amp; \
    mv remco_linux /bin/remco

COPY config /etc/remco/config
COPY haproxy.tmpl /etc/remco/templates/haproxy.tmpl

ENTRYPOINT [&amp;quot;remco&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-and-run-the-container&#34;&gt;Build and Run the container&lt;/h2&gt;

&lt;p&gt;You should have three files at this point:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── config
├── Dockerfile
└── haproxy.tmpl
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;build-the-docker-container&#34;&gt;Build the docker container:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo docker build -t remcohaproxy .
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;optionally-test-the-container&#34;&gt;Optionally test the container:&lt;/h3&gt;

&lt;h4 id=&#34;put-some-data-into-etcd&#34;&gt;put some data into etcd:&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;etcdctl set /services/exampleService/1 someip:port
etcdctl set /config/exampleService/scheme http
etcdctl set /config/exampleService/host_port 1234
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example we connect to a local etcd cluster.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo docker run --rm -ti --net=host -e ETCD_NODE=http://localhost:2379 remcohaproxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Dec 16 18:26:20]  INFO remco[1]: Target config out of sync config=/etc/haproxy/haproxy.cfg resource=haproxy source=resource.go:66
[Dec 16 18:26:20] DEBUG remco[1]: Overwriting target config config=/etc/haproxy/haproxy.cfg resource=haproxy source=resource.go:66
[Dec 16 18:26:20] DEBUG remco[1]: Running haproxy -f /etc/haproxy/haproxy.cfg -p /var/run/haproxy.pid -D -sf `cat /var/run/haproxy.pid` resource=haproxy source=resource.go:66
[Dec 16 18:26:20] DEBUG remco[1]: &amp;quot;&amp;quot; resource=haproxy source=resource.go:66
[Dec 16 18:26:20]  INFO remco[1]: Target config has been updated config=/etc/haproxy/haproxy.cfg resource=haproxy source=resource.go:66
[Dec 16 18:26:20] DEBUG remco[1]: [Reaped child process 60] source=main.go:87
[Dec 16 18:26:24] DEBUG remco[1]: Retrieving keys backend=etcd key_prefix= resource=haproxy source=resource.go:66
[Dec 16 18:26:24] DEBUG remco[1]: Compiling source template resource=haproxy source=resource.go:66 template=/etc/remco/templates/haproxy.tmpl
[Dec 16 18:26:24] DEBUG remco[1]: Comparing staged and dest config files dest=/etc/haproxy/haproxy.cfg resource=haproxy source=resource.go:66 staged=.haproxy.cfg389124299
[Dec 16 18:26:24] DEBUG remco[1]: Target config in sync config=/etc/haproxy/haproxy.cfg resource=haproxy source=resource.go:66
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;run-registrator&#34;&gt;Run registrator&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sudo docker run -d \
    --name=registrator \
    --net=host \
    --volume=/var/run/docker.sock:/tmp/docker.sock \
    gliderlabs/registrator:latest \
      etcd://localhost:2379/services
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now every container get automatically registered under /services.
You can then configure the scheme and optionally the host_port of each service that you want to expose.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>environment variables</title>
      <link>https://heavyhorst.github.io/remco/config/environment-variables/</link>
      <pubDate>Sat, 03 Dec 2016 14:56:09 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/config/environment-variables/</guid>
      <description>&lt;p&gt;If you wish to use environmental variables in your config files as a way
to configure values, you can simply use $VARIABLE_NAME or ${VARIABLE_NAME} and the text will be replaced with the value of the environmental variable VARIABLE_NAME.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>template resource</title>
      <link>https://heavyhorst.github.io/remco/details/template-resource/</link>
      <pubDate>Sat, 03 Dec 2016 14:20:57 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/details/template-resource/</guid>
      <description>&lt;p&gt;A template resource in remco consists of the following parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;one optional exec command.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;one or many templates.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;one or many backends.&lt;/strong&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;notices note&#34; &gt;&lt;p&gt;Please note that it is not possible to use the same backend more than once per template resource.
It is for example not possible to use two different redis servers.&lt;/p&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>consul plugin example</title>
      <link>https://heavyhorst.github.io/remco/plugins/consul-plugin-example/</link>
      <pubDate>Sat, 03 Dec 2016 15:14:31 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/plugins/consul-plugin-example/</guid>
      <description>&lt;p&gt;Here is another simple example plugin that speaks to the consul service endpoint instead of the consul kv-store like the built in consul backend.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/rpc/jsonrpc&amp;quot;
	&amp;quot;path&amp;quot;
	&amp;quot;strconv&amp;quot;

	&amp;quot;github.com/HeavyHorst/easyKV&amp;quot;
	&amp;quot;github.com/HeavyHorst/remco/backends/plugin&amp;quot;
	consul &amp;quot;github.com/hashicorp/consul/api&amp;quot;
	&amp;quot;github.com/natefinch/pie&amp;quot;
)

func NewConsulClient(addr string) (*consul.Client, error) {
	config := consul.DefaultConfig()
	config.Address = addr
	c, err := consul.NewClient(config)
	if err != nil {
		return nil, err
	}
	return c, nil
}

type ConsulRPCServer struct {
	client *consul.Client
}

func main() {
	p := pie.NewProvider()
	if err := p.RegisterName(&amp;quot;Plugin&amp;quot;, &amp;amp;ConsulRPCServer{}); err != nil {
		log.Fatalf(&amp;quot;failed to register Plugin: %s&amp;quot;, err)
	}
	p.ServeCodec(jsonrpc.NewServerCodec)
}

func (c *ConsulRPCServer) Init(args map[string]string, resp *bool) error {
	var err error
	if addr, ok := args[&amp;quot;addr&amp;quot;]; ok {
		c.client, err = NewConsulClient(addr)
		if err != nil {
			return err
		}
		*resp = true
		return nil
	}
	return fmt.Errorf(&amp;quot;I need an Address !&amp;quot;)
}

func (c *ConsulRPCServer) GetValues(args []string, resp *map[string]string) error {
	r := make(map[string]string)
	passingOnly := true
	for _, v := range args {
		addrs, _, err := c.client.Health().Service(v, &amp;quot;&amp;quot;, passingOnly, nil)
		if len(addrs) == 0 &amp;amp;&amp;amp; err == nil {
			log.Printf(&amp;quot;service ( %s ) was not found&amp;quot;, v)
		}
		if err != nil {
			return err
		}

		for idx, addr := range addrs {
			key := path.Join(&amp;quot;/&amp;quot;, &amp;quot;_consul&amp;quot;, &amp;quot;service&amp;quot;, addr.Service.Service, strconv.Itoa(idx))
			service_json, _ := json.Marshal(addr)
			r[key] = string(service_json)
		}
	}
	*resp = r
	return nil
}

func (c *ConsulRPCServer) Close(args interface{}, resp *interface{}) error {
	// consul client doesn&#39;t need to be closed
	return nil
}

func (c *ConsulRPCServer) WatchPrefix(args plugin.WatchConfig, resp *uint64) error {
	return easyKV.ErrWatchNotSupported
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The config backend section could look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[backend]
  [[backend.plugin]]
    path = &amp;quot;/etc/remco/plugins/consul-service&amp;quot;
    keys = [&amp;quot;consul&amp;quot;]
    interval = 60
    onetime = false
    [backend.plugin.config]
	 addr = &amp;quot;localhost:8500&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>configuration options</title>
      <link>https://heavyhorst.github.io/remco/config/configuration-options/</link>
      <pubDate>Sat, 03 Dec 2016 14:57:13 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/config/configuration-options/</guid>
      <description>

&lt;h2 id=&#34;global-configuration-options&#34;&gt;Global configuration options&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;log_level(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Valid levels are panic, fatal, error, warn, info and debug. Default is info.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;log_format(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The format of the log messages. Valid formats are &lt;em&gt;text&lt;/em&gt; and &lt;em&gt;json&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;include_dir(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Specify an entire directory of resource configuration files to include. Data from files will be imported directly into &lt;code&gt;resource&lt;/code&gt; array.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;filter_dir(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;A folder with custom JavaScript template filters.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pid_file(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;A filename to write the process-id to.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;log_file(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Specify the log file name. The empty string means to log to stdout.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;resource-configuration-options&#34;&gt;Resource configuration options&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;name(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;You can give the resource a name which is added to the logs as field &lt;em&gt;resource&lt;/em&gt;. Default is the name of the resource file.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;start_cmd(string, optional)&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;An optional command which is executed once all templates have been processed successfully.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reload_cmd(string, optional)&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;An optional command which is executed as soon as a template belonging to the resource has been successfully recreated.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exec-configuration-options&#34;&gt;Exec configuration options&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;command(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;This is the command to exec as a child process. Note that the child process must remain in the foreground.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;kill_signal(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;This defines the signal sent to the child process when remco is gracefully shutting down. The application needs to exit before the &lt;code&gt;kill_timeout&lt;/code&gt;,
it will be terminated otherwise (like kill -9). The default value is &amp;ldquo;SIGTERM&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;kill_timeout(int):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;the maximum amount of time (seconds) to wait for the child process to gracefully terminate. Default is 10.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reload_signal(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;This defines the signal sent to the child process when some configuration data is changed. If no signal is specified the child process will be killed (gracefully) and started again.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;splay(int):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;A random splay to wait before killing the command. May be useful in large clusters to prevent all child processes to reload at the same time when configuration changes occur. Default is 0.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;template-configuration-options&#34;&gt;Template configuration options&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;src(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The path of the template that will be used to render the application&amp;rsquo;s configuration file.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dst(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The location to place the rendered configuration file.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;make_directories(bool, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;make parent directories for the dst path as needed. Default is false.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;check_cmd(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;An optional command to check the rendered source template before writing it to the destination. If this command returns non-zero, the destination will not be overwritten by the rendered source template. We can use &lt;code&gt;{{.src}}&lt;/code&gt; here to reference the rendered source template.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reload_cmd(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;An optional command to run after the destination is updated. We can use &lt;code&gt;{{.dst}}&lt;/code&gt; here to reference the destination.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mode(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The permission mode of the file. Default is &amp;ldquo;0644&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UID(int, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The UID that should own the file. Defaults to the effective uid.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GID(int, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The GID that should own the file. Defaults to the effective gid.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;backend-configuration-options&#34;&gt;Backend configuration options&lt;/h2&gt;

&lt;p&gt;See the example configuration to see how global default values can be set for individual backends.&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;valid in every backend&lt;/strong&gt; &lt;/summary&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;keys([]string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The backend keys that the template requires to be rendered correctly. The child keys are also loaded.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;watch(bool, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Enable watch support. Default is false.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;prefix(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Key path prefix. Default is &amp;ldquo;&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;watchKeys([]string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Keys list to watch. Default is same as keys&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;interval(int, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The backend polling interval. Can be used as a reconciliation loop for watch or standalone.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;onetime(bool, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Render the config file and quit. Default is false.
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;etcd&lt;/strong&gt; &lt;/summary&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;nodes([]string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;List of backend nodes.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;srv_record(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;A DNS server record to discover the etcd nodes.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scheme(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The backend URI scheme (http or https). This is only used when the nodes are discovered via DNS srv records and the api level is 2. Default is http.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;client_cert(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The client cert file.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;client_key(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The client key file.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;client_ca_keys(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The client CA key file.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;username(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The username for the basic_auth authentication.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;password(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The password for the basic_auth authentication.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;version(uint, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The etcd api-level to use (2 or 3). Default is 2.
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;nats&lt;/strong&gt; &lt;/summary&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;nodes([]string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;List of backend nodes. If none is provided nats.DefaultURL is used.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bucket(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The nats kv bucket where your config keys are stored&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;username(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The username for the basic_auth authentication.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;password(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The password for the basic_auth authentication.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;token(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The athentication token for the nats server&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;creds(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The path to an NATS 2.0 and NATS NGS compatible user credentials file
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;consul&lt;/strong&gt; &lt;/summary&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;nodes([]string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;List of backend nodes.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;srv_record(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;A DNS server record to discover the consul nodes.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scheme(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The backend URI scheme (http or https).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;client_cert(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The client cert file.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;client_key(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The client key file.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;client_ca_keys(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The client CA key file.
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;file&lt;/strong&gt; &lt;/summary&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;filepath(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The filepath to a yaml or json file containing the key-value pairs. This can be a local file or a remote http/https location.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;httpheaders(map[string]string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Optional HTTP-headers to append to the request if the file path is a remote http/https location.
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;redis&lt;/strong&gt; &lt;/summary&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;nodes([]string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;List of backend nodes.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;srv_record(string), optional:&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;A DNS server record to discover the redis nodes.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;password(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The redis password.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;database(int, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The redis database.
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;vault&lt;/strong&gt; &lt;/summary&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;node(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The backend node.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;auth_type(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The vault authentication type. (token, approle, app-id, userpass, github, cert, kubernetes)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;auth_token(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The vault authentication token. Only used with auth_type=token or github.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;role_id(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The vault app role. Only used with auth_type=approle and kubernetes.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;secret_id(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The vault secret id. Only used with auth_type=approle.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;app_id(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The vault app ID. Only used with auth_type=app-id.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;user_id(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The vault user ID. Only used with auth_type=app-id.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;username(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The username for the userpass authentication.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;password(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The password for the userpass authentication.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;client_cert(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The client cert file.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;client_key(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The client key file.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;client_ca_keys(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;The client CA key file.
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;env&lt;/strong&gt; &lt;/summary&gt;
&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;zookeeper&lt;/strong&gt; &lt;/summary&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;nodes([]string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;List of backend nodes.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;srv_record(string, optional):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;A DNS server record to discover the zookeeper nodes.
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;telemetry-configuration-options&#34;&gt;Telemetry configuration options&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;enabled(bool):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Flag to enable telemetry.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;service_name(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Service name to add to every metric name. &amp;ldquo;remco&amp;rdquo; by default&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hostname(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Hostname to use. If not provided and enable_hostname, it will be os.Hostname&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enable_hostname(bool):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Enable prefixing gauge values with hostname. &lt;code&gt;true&lt;/code&gt; by default&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enable_hostname_label(bool):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Put hostname into label instead of metric name. &lt;code&gt;false&lt;/code&gt; by default&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;enable_runtime_metrics(bool):&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Enables profiling of runtime metrics (GC, Goroutines, Memory). &lt;code&gt;true&lt;/code&gt; by default&lt;/p&gt;

&lt;h2 id=&#34;sink-configuration-options&#34;&gt;Sink configuration options&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;inmem&lt;/strong&gt; &lt;/summary&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;interval(int):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;How long is each aggregation interval (seconds).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;retain(int):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Retain controls how many metrics interval we keep.
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;prometheus&lt;/strong&gt; &lt;/summary&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;addr(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Address to expose metrics on. Prometheus stats will be available at /metrics endpoint.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;expiration(int):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Expiration is the duration a metric is valid for, after which it will be untracked. If the value is zero, a metric is never expired.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;div class=&#34;notices note&#34; &gt;&lt;p&gt;If you are using only prometheus sink you may want to disable runtime metrics with &lt;strong&gt;enable_runtime_metrics&lt;/strong&gt; option,
because they will duplicate prometheus builtin runtime metrics reporting. Also, consider using &lt;strong&gt;enable_hostname_label&lt;/strong&gt;
to put hostname in gauge metrics to label instead of metric name.&lt;/p&gt;
&lt;/div&gt;

&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;statsd&lt;/strong&gt; &lt;/summary&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;addr(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Statsd/Statsite server address
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt; &lt;strong&gt;statsite&lt;/strong&gt; &lt;/summary&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;addr(string):&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Statsd/Statsite server address
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>exec mode</title>
      <link>https://heavyhorst.github.io/remco/details/exec-mode/</link>
      <pubDate>Sat, 03 Dec 2016 14:23:28 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/details/exec-mode/</guid>
      <description>&lt;p&gt;Remco has the ability to run one arbitary child process per template resource.
When any of the provided templates change and the check command (if any) succeeds, remco will send the configurable reload signal to the child process.
Remco will kill and restart the child process if no reload signal is provided.
Additionally, every signal that remco receives will be forwarded to the child process.&lt;/p&gt;

&lt;p&gt;The template resource will fail if the child process dies. It will be automatically restarted after a random amount of time (0-30s).
This also means that the child needs to remain in the foreground, otherwise the template resource will be restarted endlessly.&lt;/p&gt;

&lt;p&gt;The exec configuration parameters can be found here: &lt;a href=&#34;./config/configuration-options/#exec-configuration-options&#34;&gt;exec configuration&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sample config file</title>
      <link>https://heavyhorst.github.io/remco/config/sample-config/</link>
      <pubDate>Sat, 03 Dec 2016 14:59:49 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/config/sample-config/</guid>
      <description>&lt;pre&gt;&lt;code&gt;#remco.toml
################################################################
# Global configuration
################################################################
log_level   = &amp;quot;debug&amp;quot;
log_format  = &amp;quot;json&amp;quot;
include_dir = &amp;quot;/etc/remco/resource.d/&amp;quot;
pid_file    = &amp;quot;/var/run/remco/remco.pid&amp;quot;
log_file    = &amp;quot;/var/log/remco.log&amp;quot;

# default backend configurations.
# these settings can be overwritten in the individual resource backend settings.
[default_backends]
[default_backends.file]
    onetime  = true
    prefix   = &amp;quot;/bla&amp;quot;

################################################################
# Resource configuration
################################################################
[[resource]]
  name = &amp;quot;haproxy&amp;quot;
  start_cmd   = &amp;quot;echo 1&amp;quot;
  reload_cmd  = &amp;quot;echo 1&amp;quot;
  [[resource.template]]
    src         = &amp;quot;/etc/remco/templates/haproxy.cfg&amp;quot;
    dst         = &amp;quot;/etc/haproxy/haproxy.cfg&amp;quot;
    check_cmd   = &amp;quot;somecommand&amp;quot;
    reload_cmd  = &amp;quot;somecommand&amp;quot;
    mode        = &amp;quot;0644&amp;quot;

  [resource.backend]
    # you can use as many backends as you like
	  # in this example vault and file
    [resource.backend.vault]
      node           = &amp;quot;http://127.0.0.1:8200&amp;quot;
      ## Token based auth backend
      auth_type      = &amp;quot;token&amp;quot;
      auth_token     = &amp;quot;vault_token&amp;quot;
      ## AppID based auth backend
      # auth_type    = &amp;quot;app-id&amp;quot;
      # app_id       = &amp;quot;vault_app_id&amp;quot;
      # user_id      = &amp;quot;vault_user_id&amp;quot;
      ## userpass based auth backend
      # auth_type    = &amp;quot;userpass&amp;quot;
      # username     = &amp;quot;username&amp;quot;
      # password     = &amp;quot;password&amp;quot;
      client_cert    = &amp;quot;/path/to/client_cert&amp;quot;
      client_key     = &amp;quot;/path/to/client_key&amp;quot;
      client_ca_keys = &amp;quot;/path/to/client_ca_keys&amp;quot;
      
	  # These values are valid in every backend
      watch    = true
      prefix   = &amp;quot;/&amp;quot;
      onetime  = true
      interval = 1
      keys     = [&amp;quot;/&amp;quot;]
      watchKeys = [&amp;quot;/haproxy/reload&amp;quot;]

    [resource.backend.file]
      httpheader = { X-Test-Token = &amp;quot;XXX&amp;quot;, X-Test-Token2 = &amp;quot;YYY&amp;quot; } 
      filepath = &amp;quot;/etc/remco/test.yml&amp;quot;
	    watch    = true
	    keys     = [&amp;quot;/prefix&amp;quot;]

################################################################
# Telemetry configuration
################################################################
[telemetry]
  enabled = true
  [telemetry.sinks.prometheus]
    addr = &amp;quot;:2112&amp;quot;
    expiration = 600
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>commands</title>
      <link>https://heavyhorst.github.io/remco/details/commands/</link>
      <pubDate>Sat, 03 Dec 2016 14:25:24 +0100</pubDate>
      
      <guid>https://heavyhorst.github.io/remco/details/commands/</guid>
      <description>&lt;p&gt;Each template can have its own reload and check command. Both commands are executed in a sh-shell which means that operations like environment variable substitution or pipes should work correctly.&lt;/p&gt;

&lt;p&gt;In the check command its additionally possible to reference to the rendered source template with {{ .src }}.&lt;/p&gt;

&lt;p&gt;The check command must exit with status code 0 so that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the reload command runs&lt;/li&gt;
&lt;li&gt;the child process gets reloaded&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The template configuration parameters can be found here: &lt;a href=&#34;./config/configuration-options/#template-configuration-options&#34;&gt;template configuration&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>